{
  "code" : "org.manaty.webapp.WebApp",
  "description" : "Serve Meveo Web Application",
  "inputs" : [ {
    "name" : "appCode",
    "type" : "String"
  } ],
  "outputs" : [ {
    "name" : "result",
    "type" : "Object"
  }, {
    "name" : "appCode",
    "type" : "String"
  } ],
  "generateOutputs" : false,
  "type" : "JAVA",
  "transactionType" : "SAME",
  "script" : "/*\r\n * (C) Copyright 2018-2019 Manaty SARL (https://manaty.net) and contributors.\r\n *\r\n * This program is free software: you can redistribute it and/or modify it under the terms of the\r\n * GNU Affero General Public License as published by the Free Software Foundation, either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. This program is\r\n * not suitable for any direct or indirect application in MILITARY industry See the GNU Affero\r\n * General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License along with this program.\r\n * If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage org.manaty.webapp;\r\n\r\nimport org.apache.commons.io.FileUtils;\r\nimport org.meveo.api.exception.EntityDoesNotExistsException;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.api.rest.technicalservice.impl.EndpointResponse;\r\nimport org.meveo.api.rest.technicalservice.impl.EndpointRequest;\r\nimport org.meveo.commons.utils.ParamBean;\r\nimport org.meveo.commons.utils.ParamBeanFactory;\r\nimport org.meveo.model.crm.EntityReferenceWrapper;\r\nimport org.meveo.model.customEntities.CustomEntityInstance;\r\nimport org.meveo.model.customEntities.WebApplication;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.service.custom.CustomEntityInstanceService;\r\nimport org.meveo.service.git.GitHelper;\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport java.io.File;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.io.IOException;\r\nimport java.net.URLDecoder;\r\nimport java.util.Arrays;\r\nimport java.util.Map;\r\nimport java.util.function.UnaryOperator;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class WebApp extends Script {\r\n\r\n    private static final int DEFAULT_BUFFER_SIZE = 10240;\r\n    private static final long DEFAULT_EXPIRE_TIME = 604800000L;\r\n    private static final String CRLF = \"\\r\\n\";\r\n    private static final String ENDPOINT_URL = \"/rest/webapp/\";\r\n    private static final String INDEX_FILE = \"index.html\";\r\n    private static final String PNG_TYPE = \"image/png\";\r\n    private static final String AFFIX = \"-UI\";\r\n    private static final String DEFAULT_ICON = \"https://avatars1.githubusercontent.com/u/59589948?s=200&v=4\";\r\n    private static final String INDEX_REPLACE_START = \"<!-- REPLACE TEMPLATE SECTION START -->\";\r\n    private static final String INDEX_REPLACE_END = \"<!-- REPLACE TEMPLATE SECTION END -->\";\r\n    private static final String TITLE_TEMPLATE = \"<title>%s</title>\";\r\n    private static final String FAVICON_TEMPLATE = \"<link rel=\\\"icon\\\" type=\\\"%s\\\" href=\\\"%s\\\" />\";\r\n    private static final String BASEURL_TEMPLATE = \"<base href=\\\"%s\\\" />\";\r\n\r\n    private static final Logger LOG = LoggerFactory.getLogger(WebApp.class);\r\n\r\n    private ParamBeanFactory paramBeanFactory = getCDIBean(ParamBeanFactory.class);\r\n    private CustomEntityInstanceService ceiService = getCDIBean(CustomEntityInstanceService.class);\r\n    private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n    private CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n    private ParamBean config = paramBeanFactory.getInstance();\r\n    private Repository repository = repositoryService.findDefaultRepository();\r\n\r\n    private EndpointRequest request;\r\n    private String basePath;\r\n    private String webappPath;\r\n    private Object result = \"\";\r\n    private String appCode = \"\";\r\n\r\n    public WebApp() {\r\n        basePath = config.getProperty(\"providers.rootDir\", File.separator + \"meveodata\");\r\n        String rootDirectory = config.getProperty(\"provider.rootDir\", \"default\");\r\n        basePath += File.separator + rootDirectory + File.separator;\r\n        webappPath = basePath + \"webapp\" + File.separator;\r\n        LOG.info(\"basePath: {}\", basePath);\r\n        LOG.info(\"webappPath: {}\", basePath);\r\n        File path = new File(webappPath);\r\n        if (!path.exists()) {\r\n            path.mkdirs();\r\n        }\r\n    }\r\n\r\n    public Object getResult() {\r\n        return result;\r\n    }\r\n\r\n    public String getAppCode() {\r\n        return appCode;\r\n    }\r\n\r\n    public void setAppCode(String appCode) {\r\n        this.appCode = appCode;\r\n    }\r\n\r\n    @Override\r\n    public void execute(Map<String, Object> methodContext) {\r\n        this.request = (EndpointRequest) methodContext.get(\"request\");\r\n        EndpointResponse response = (EndpointResponse) methodContext.get(\"response\");\r\n        String remainingPath = request.getRemainingPath();\r\n        LOG.info(\"appCode: \" + this.appCode);\r\n        LOG.info(\"remainingPath: \" + remainingPath);\r\n        String appPath = \"/\" + this.appCode + AFFIX;\r\n        String rootPath = null;\r\n        if (remainingPath.equalsIgnoreCase(appPath)) {\r\n            rootPath = webappPath;\r\n        } else {\r\n            rootPath = webappPath + this.appCode + AFFIX;\r\n        }\r\n        try {\r\n            // we first try to get the file from file explorer under the webapp/appCode/\r\n            // directory\r\n            File file = lookupFile(rootPath, remainingPath);\r\n            if (file == null) {\r\n                LOG.info(\"File not found in webapp, we look in git\");\r\n                File repositoryDir = GitHelper.getRepositoryDir(null, this.appCode + AFFIX);\r\n                rootPath = repositoryDir.getPath().toString();\r\n                file = lookupFile(rootPath, remainingPath);\r\n                // file still doesnt exist, we build it\r\n                if (file == null) {\r\n                    LOG.info(\"File not found in git, we build it\");\r\n                    WebApplication app = crossStorageApi.find(repository, WebApplication.class).by(\"code\", this.appCode)\r\n                            .getResult();\r\n                    CustomEntityInstance instance = crossStorageApi.find(repository, app.getUuid(), app.getCetCode());\r\n                    result = org.manaty.webapp.HtmlApplicationSerializer.getHtml(instance, remainingPath, ceiService);\r\n                    return;\r\n                }\r\n            }\r\n            serveFile(file, request, response);\r\n        } catch (IOException | EntityDoesNotExistsException exception) {\r\n            response.setStatus(400);\r\n            result = \"Encountered error while trying to load \" + remainingPath;\r\n        }\r\n    }\r\n\r\n    private File lookupFile(String rootPath, String remainingPath) throws java.io.IOException {\r\n        // load the file as-is at first\r\n        File file = new File(rootPath, URLDecoder.decode(remainingPath, \"UTF-8\"));\r\n        LOG.info(\"Looking for \" + remainingPath + \" in \" + rootPath);\r\n        // we attempt to load the index.html from the directory first.\r\n        if (!file.exists() || file.isDirectory()) {\r\n            if (file.isDirectory()) {\r\n                int subFolderIndex = remainingPath.indexOf(\"/\", 1);\r\n                String subFolder = subFolderIndex > -1 ? remainingPath.substring(0, subFolderIndex) : remainingPath;\r\n                LOG.info(\"Attempt to load index.html from \" + subFolder);\r\n                file = new File(rootPath, URLDecoder.decode(subFolder + File.separator + INDEX_FILE, \"UTF-8\"));\r\n            }\r\n            // default to rootPath's index.html\r\n            if (!file.exists()) {\r\n                LOG.info(\"Attempt to load index.html from \" + rootPath);\r\n                String baseIndexPath = rootPath + File.separator;\r\n                File indexTemplate = new File(baseIndexPath + INDEX_FILE);\r\n                String repoPath = GitHelper.getRepositoryDir(null, this.appCode + AFFIX).toPath().toString();\r\n                String rootIndex = repoPath + File.separator + INDEX_FILE;\r\n                boolean isAppIndex = indexTemplate.getAbsolutePath().contains(rootIndex);\r\n\r\n                LOG.info(\"indexPath: {}\", indexTemplate.getAbsolutePath());\r\n                LOG.info(\"repoPath: {}\", repoPath);\r\n                LOG.info(\"rootIndex: {}\", rootIndex);\r\n                LOG.info(\"isAppIndex: {}\", isAppIndex);\r\n                if (isAppIndex) {\r\n                    File generatedIndex = new File(baseIndexPath + \"generated_index.html\");\r\n                    if (!generatedIndex.exists()) {\r\n                        String indexContents = new String(Files.readAllBytes(indexTemplate.toPath()));\r\n                        int start = indexContents.indexOf(INDEX_REPLACE_START);\r\n                        int end = indexContents.indexOf(INDEX_REPLACE_END);\r\n                        String topContent = indexContents.substring(0, start);\r\n                        String endContent = indexContents.substring(end + INDEX_REPLACE_END.length());\r\n                        String title = String.format(TITLE_TEMPLATE, WebAppScriptHelper.toTitleName(this.appCode));\r\n                        String iconType = PNG_TYPE;\r\n                        String iconUrl = DEFAULT_ICON;\r\n                        String favIcon = String.format(FAVICON_TEMPLATE, iconType, iconUrl);\r\n                        String contextPath = request.getContextPath() + ENDPOINT_URL + this.appCode + \"/\";\r\n                        String baseUrl = String.format(BASEURL_TEMPLATE, contextPath);\r\n                        String newContent = topContent + CRLF + title + CRLF + favIcon + CRLF + baseUrl + CRLF\r\n                                + endContent;\r\n                        FileUtils.writeStringToFile(generatedIndex, newContent);\r\n                    }\r\n                    file = generatedIndex;\r\n                }\r\n            }\r\n            // if an index.html file does not exist in both rootPath and subdirectory, we\r\n            // return null\r\n            if (!file.exists()) {\r\n                return null;\r\n            }\r\n        }\r\n        LOG.info(\"Lookup returning file: {}\", file.toPath());\r\n        return file;\r\n    }\r\n\r\n    private void serveFile(File file, EndpointRequest request, EndpointResponse response) {\r\n        LOG.info(\"Serving file \" + file.getAbsolutePath());\r\n        // Prepare some variables. The ETag is an unique identifier of the file.\r\n        String fileName = file.getName();\r\n        long length = file.length();\r\n        long lastModified = file.lastModified();\r\n        String eTag = fileName + \"_\" + length + \"_\" + lastModified;\r\n        long expires = System.currentTimeMillis() + DEFAULT_EXPIRE_TIME;\r\n        // Validate request headers for caching\r\n        // ---------------------------------------------------\r\n        // If-None-Match header should contain \"*\" or ETag. If so, then return 304.\r\n        String ifNoneMatch = request.getHeader(\"If-None-Match\");\r\n        if (ifNoneMatch != null && matches(ifNoneMatch, eTag)) {\r\n            response.setStatus(304);\r\n            // Required in 304.\r\n            response.setHeader(\"ETag\", eTag);\r\n            // Postpone cache with 1 week.\r\n            response.setDateHeader(\"Expires\", expires);\r\n            LOG.info(\"If-None-Match\");\r\n            return;\r\n        }\r\n        // If-Modified-Since header should be greater than LastModified. If so, then\r\n        // return 304.\r\n        // This header is ignored if any If-None-Match header is specified.\r\n        long ifModifiedSince = request.getDateHeader(\"If-Modified-Since\");\r\n        if (ifNoneMatch == null && ifModifiedSince != -1 && ifModifiedSince + 1000 > lastModified) {\r\n            response.setStatus(304);\r\n            // Required in 304.\r\n            response.setHeader(\"ETag\", eTag);\r\n            // Postpone cache with 1 week.\r\n            response.setDateHeader(\"Expires\", expires);\r\n            LOG.info(\"If-Modified-Match\");\r\n            return;\r\n        }\r\n        // Validate request headers for resume\r\n        // ----------------------------------------------------\r\n        // If-Match header should contain \"*\" or ETag. If not, then return 412.\r\n        String ifMatch = request.getHeader(\"If-Match\");\r\n        if (ifMatch != null && !matches(ifMatch, eTag)) {\r\n            response.setStatus(412);\r\n            LOG.info(\"If-Match\");\r\n            return;\r\n        }\r\n        // If-Unmodified-Since header should be greater than LastModified. If not, then\r\n        // return 412.\r\n        long ifUnmodifiedSince = request.getDateHeader(\"If-Unmodified-Since\");\r\n        if (ifUnmodifiedSince != -1 && ifUnmodifiedSince + 1000 <= lastModified) {\r\n            response.setStatus(412);\r\n            LOG.info(\"If-Unmodified-Since\");\r\n            return;\r\n        }\r\n        // Prepare and initialize response\r\n        // --------------------------------------------------------\r\n        // Get content type by file name and set default GZIP support and content\r\n        // disposition.\r\n        String contentType = request.getServletContext().getMimeType(fileName);\r\n        LOG.info(\"Servlet context found MIME=\" + contentType);\r\n        boolean acceptsGzip = false;\r\n        String disposition = \"inline\";\r\n        // To add new content types, add new mime-mapping entry in web.xml.\r\n        if (contentType == null) {\r\n            if (fileName.endsWith(\".js\")) {\r\n                contentType = \"application/javascript\";\r\n            }\r\n            contentType = \"application/octet-stream\";\r\n        }\r\n        // the browser and expand content type with the one and right character\r\n        // encoding.\r\n        if (contentType.startsWith(\"text\")) {\r\n            String acceptEncoding = request.getHeader(\"Accept-Encoding\");\r\n            acceptsGzip = acceptEncoding != null && accepts(acceptEncoding, \"gzip\");\r\n            contentType += \";charset=UTF-8\";\r\n        } else // the browser, then set to inline, else attachment which will pop a 'save as'\r\n               // dialogue.\r\n        if (!contentType.startsWith(\"image\")) {\r\n            String accept = request.getHeader(\"Accept\");\r\n            disposition = accept != null && accepts(accept, contentType) ? \"inline\" : \"attachment\";\r\n        }\r\n        LOG.info(\" content-type:\" + contentType);\r\n        // Initialize response.\r\n        response.setBufferSize(DEFAULT_BUFFER_SIZE);\r\n        response.setContentType(contentType);\r\n        response.setHeader(\"Content-Disposition\", disposition + \";filename=\\\"\" + fileName + \"\\\"\");\r\n        response.setHeader(\"Accept-Ranges\", \"bytes\");\r\n        response.setHeader(\"ETag\", eTag);\r\n        response.setDateHeader(\"Last-Modified\", lastModified);\r\n        response.setDateHeader(\"Expires\", expires);\r\n        try {\r\n            response.setOutput(Files.readAllBytes(file.toPath()));\r\n        } catch (IOException ioException) {\r\n            response.setStatus(400);\r\n            response.setErrorMessage(\"Encountered error while trying to load \" + fileName);\r\n        }\r\n    }\r\n\r\n    // Helpers (can be refactored to public utility class)\r\n    // ----------------------------------------\r\n    /**\r\n     * Returns true if the given accept header accepts the given value.\r\n     *\r\n     * @param acceptHeader The accept header.\r\n     * @param toAccept     The value to be accepted.\r\n     * @return True if the given accept header accepts the given value.\r\n     */\r\n    private static boolean accepts(String acceptHeader, String toAccept) {\r\n        String[] acceptValues = acceptHeader.split(\"\\\\s*(,|;)\\\\s*\");\r\n        Arrays.sort(acceptValues);\r\n        return Arrays.binarySearch(acceptValues, toAccept) > -1\r\n                || Arrays.binarySearch(acceptValues, toAccept.replaceAll(\"/.*$\", \"/*\")) > -1\r\n                || Arrays.binarySearch(acceptValues, \"*/*\") > -1;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given match header matches the given value.\r\n     *\r\n     * @param matchHeader The match header.\r\n     * @param toMatch     The value to be matched.\r\n     * @return True if the given match header matches the given value.\r\n     */\r\n    private static boolean matches(String matchHeader, String toMatch) {\r\n        String[] matchValues = matchHeader.split(\"\\\\s*,\\\\s*\");\r\n        Arrays.sort(matchValues);\r\n        return Arrays.binarySearch(matchValues, toMatch) > -1 || Arrays.binarySearch(matchValues, \"*\") > -1;\r\n    }\r\n}\r\n\r\nclass HtmlApplicationSerializer {\r\n\r\n    static final String docType = \"<!DOCTYPE html>\";\r\n\r\n    static final String ln = System.lineSeparator();\r\n\r\n    static CustomEntityInstanceService customEntityInstanceService;\r\n\r\n    static String getHtml(CustomEntityInstance app, String remainingPath, CustomEntityInstanceService ceis) {\r\n        customEntityInstanceService = ceis;\r\n        if (app.getCfValues().getCfValue(\"webPages\") == null) {\r\n            return docType + \"<html><body><h1>\" + app.getDescription() + \"</h1></body></html>\";\r\n        }\r\n        Map<String, EntityReferenceWrapper> webpages = (Map<String, EntityReferenceWrapper>) app.getCfValues()\r\n                .getCfValue(\"webPages\").getMapValue();\r\n        EntityReferenceWrapper webpage = null;\r\n        if (webpages != null && webpages.containsKey(remainingPath)) {\r\n            webpage = webpages.get(remainingPath);\r\n        }\r\n        if (webpage == null) {\r\n            return docType + \"<html><body><h1>Page \" + remainingPath + \" not found among \"\r\n                    + app.getCfValues().getValues() + \"</h1></body></html>\";\r\n        }\r\n        StringBuilder result = new StringBuilder();\r\n        result.append(docType).append(ln);\r\n        result.append(\"<html>\").append(ln);\r\n        result.append(\"<head>\").append(ln);\r\n        if (app.getCfValues().getCfValue(\"stylesheets\") != null) {\r\n            Map<String, EntityReferenceWrapper> stylesheets = (Map<String, EntityReferenceWrapper>) app.getCfValues()\r\n                    .getCfValue(\"stylesheets\").getListValue();\r\n            if (stylesheets != null && stylesheets.size() > 0) {\r\n                result.append(getStyleSheets(stylesheets));\r\n            }\r\n        }\r\n        result.append(getWebpageHtml(webpage));\r\n        result.append(\"</html>\").append(ln);\r\n        return result.toString();\r\n    }\r\n\r\n    static String getWebpageHtml(EntityReferenceWrapper webpageWrapper) {\r\n        StringBuilder result = new StringBuilder();\r\n        CustomEntityInstance webpage = customEntityInstanceService.findByCodeByCet(\"ApplicationWebPage\",\r\n                webpageWrapper.getCode());\r\n        result.append(\"<title>\").append(webpage.getDescription()).append(\"</title>\");\r\n        if (webpage.getCfValues().getCfValue(\"stylesheets\") != null) {\r\n            Map<String, EntityReferenceWrapper> stylesheets = (Map<String, EntityReferenceWrapper>) webpage\r\n                    .getCfValues().getCfValue(\"stylesheets\").getListValue();\r\n            if (stylesheets != null && stylesheets.size() > 0) {\r\n                result.append(getStyleSheets(stylesheets));\r\n            }\r\n        }\r\n        result.append(\"</head>\").append(ln);\r\n        if (webpage.getCfValues().getCfValue(\"body\") != null) {\r\n            result.append(\"<body>\").append(ln).append(webpage.getCfValues().getCfValue(\"body\").getStringValue())\r\n                    .append(\"</body>\").append(ln);\r\n        }\r\n        return result.toString();\r\n    }\r\n\r\n    static String getStyleSheets(Map<String, EntityReferenceWrapper> stylesheets) {\r\n        StringBuilder result = new StringBuilder();\r\n        for (EntityReferenceWrapper stylesheetWrapper : stylesheets.values()) {\r\n            CustomEntityInstance stylesheet = customEntityInstanceService.findByCodeByCet(\"CSSStyleSheet\",\r\n                    stylesheetWrapper.getCode());\r\n            if (stylesheet.getCfValues().getCfValue(\"externalURL\") != null) {\r\n                result.append(\"<link rel=\\\"stylesheet\\\" href=\\\"\")\r\n                        .append(stylesheet.getCfValues().getCfValue(\"externalURL\").getStringValue()).append(\"\\\">\")\r\n                        .append(ln);\r\n            } else {\r\n                result.append(\"<style>\").append(stylesheet.getCfValues().getCfValue(\"content\").getStringValue())\r\n                        .append(\"</style>\").append(ln);\r\n            }\r\n        }\r\n        return result.toString();\r\n    }\r\n}\r\n\r\nclass WebAppScriptHelper {\r\n    private static final String WORD_REGEX = \"(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])|_|\\\\s|-\";\r\n    private static final String EMPTY = \"\";\r\n    private static final String SPACE = \" \";\r\n    private static final String DASH = \"-\";\r\n    private static final String UNDERSCORE = \"_\";\r\n    private static final UnaryOperator<String> TITLE_CASE = word -> word.isEmpty() ? word\r\n            : Character.toTitleCase(word.charAt(0)) + word.substring(1).toLowerCase();\r\n    private static final UnaryOperator<String> UPPER_CASE = word -> word.isEmpty() ? word : word.toUpperCase();\r\n    private static final UnaryOperator<String> LOWER_CASE = word -> word.isEmpty() ? word : word.toLowerCase();\r\n\r\n    private static final String convert(String input, UnaryOperator<String> mapper, String joinCharacter) {\r\n        if (input == null || input.isEmpty()) {\r\n            return \"\";\r\n        }\r\n        Pattern pattern = Pattern.compile(WORD_REGEX);\r\n        Matcher matcher = pattern.matcher(input);\r\n        String text = matcher.replaceAll(SPACE);\r\n        String[] words = text.split(SPACE);\r\n        return Arrays.stream(words).map(mapper).collect(Collectors.joining(joinCharacter));\r\n    }\r\n\r\n    static final String toTitleName(String input) {\r\n        return convert(input, TITLE_CASE, SPACE);\r\n    }\r\n\r\n    static final UnaryOperator<String> TITLE = WebAppScriptHelper::toTitleName;\r\n\r\n    static final String toConstantName(String input) {\r\n        return convert(input, UPPER_CASE, UNDERSCORE);\r\n    }\r\n\r\n    static final UnaryOperator<String> CONSTANT = WebAppScriptHelper::toConstantName;\r\n\r\n    static final String toVariableName(String input) {\r\n        String name = convert(input, TITLE_CASE, EMPTY);\r\n        return Character.toLowerCase(name.charAt(0)) + name.substring(1);\r\n    }\r\n\r\n    static final UnaryOperator<String> VARIABLE = WebAppScriptHelper::toVariableName;\r\n\r\n    static final String toPascalName(String input) {\r\n        String name = convert(input, TITLE_CASE, EMPTY);\r\n        return Character.toUpperCase(name.charAt(0)) + name.substring(1);\r\n    }\r\n\r\n    static final UnaryOperator<String> PASCAL = WebAppScriptHelper::toPascalName;\r\n\r\n    static final String toTagName(String input) {\r\n        return convert(input, LOWER_CASE, DASH);\r\n    }\r\n\r\n    static final UnaryOperator<String> TAG = WebAppScriptHelper::toTagName;\r\n}\r\n",
  "executionRoles" : [ ],
  "sourcingRoles" : [ ],
  "mavenDependencies" : [ ],
  "importScriptInstances" : [ ]
}